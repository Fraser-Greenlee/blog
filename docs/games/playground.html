<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pyxel Playground</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/kitao/pyxel/wasm/pyxel.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      height: 100vh;
      font-family: "Press Start 2P", serif;
      font-weight: 400;
      font-style: normal;
    }

    .container {
      height: 100vh;
      display: flex;
      gap: 0;
      padding: 4px;
      background: #1e1e1e;
      position: relative;
    }
    
    .resizer {
      width: 8px;
      height: 100%;
      background: #333;
      cursor: col-resize;
      transition: background 0.2s;
      margin: 0 4px;
      z-index: 10;
    }
    
    .resizer:hover {
      background: #555;
    }
    
    .resizer.active {
      background: #4CAF50;
    }

    .editor-panel {
      display: flex;
      flex-direction: column;
      background: #1e1e1e;
      overflow: hidden;
      flex: 1;
      min-width: 200px;
    }

    .editor-tabs {
      display: flex;
      background: #2d2d2d;
      border-bottom: 1px solid #333;
    }

    .editor-tab {
      padding: 8px 16px;
      background: #333;
      color: #fff;
      border: none;
      border-right: 1px solid #444;
      cursor: pointer;
      font-family: "Press Start 2P", serif;
      font-size: 10px;
    }

    .editor-tab.active {
      background: #1e1e1e;
      border-bottom: 1px solid #1e1e1e;
      margin-bottom: -1px;
    }

    .editor-tab-close {
      margin-left: 8px;
      color: #888;
      cursor: pointer;
    }

    .editor-tab-close:hover {
      color: #fff;
    }

    .new-tab-button {
      padding: 8px;
      background: #2d2d2d;
      color: #888;
      border: none;
      cursor: pointer;
      font-family: "Press Start 2P", serif;
      font-size: 10px;
    }

    .new-tab-button:hover {
      color: #fff;
    }

    .editor-actions {
      display: flex;
      background: #2d2d2d;
      padding: 4px;
      gap: 8px;
      border-bottom: 1px solid #333;
      justify-content: space-between;
    }
    
    .spacer {
      flex-grow: 1;
    }
    
    .examples-dropdown {
      position: relative;
      display: inline-block;
    }
    
    .dropdown-content {
      display: none;
      position: absolute;
      background-color: #333;
      min-width: 200px;
      box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.5);
      z-index: 100;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .examples-dropdown:hover .dropdown-content {
      display: block;
    }
    
    .dropdown-content a {
      color: white;
      padding: 12px 16px;
      text-decoration: none;
      display: block;
      font-size: 10px;
      text-align: left;
      transition: background-color 0.2s;
    }
    
    .dropdown-content a:hover {
      background-color: #444;
    }

    .action-button {
      padding: 8px 12px;
      background: #444;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: "Press Start 2P", serif;
      font-size: 10px;
      transition: background 0.2s;
    }

    .action-button:hover {
      background: #555;
    }

    .editor-container {
      position: relative;
      flex-grow: 1;
    }

    .editor-instance {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      display: none;
    }

    .editor-instance.active {
      display: block;
    }

    .right-panel {
      display: flex;
      flex-direction: column;
      background: #2d2d2d;
      border-radius: 4px;
      overflow: hidden;
      flex: 1;
      min-width: 200px;
    }

    .tab-controls {
      display: flex;
      background: #333;
      padding: 8px 8px 0;
    }

    .tab-controls label {
      padding: 8px 16px;
      background: #2d2d2d;
      color: #fff;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      margin-right: 4px;
    }

    .tab-radio {
      display: none;
    }

    .tab-content {
      display: none;
      flex-grow: 1;
      padding: 16px;
    }

    #tab1:checked~#content1,
    #tab2:checked~#content2 {
      display: flex;
    }

    #tab1:checked~.tab-controls label[for="tab1"],
    #tab2:checked~.tab-controls label[for="tab2"] {
      background: #1e1e1e;
    }

    canvas {
      background: #000;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    #content2 {
      display: none;
      flex-grow: 1;
      position: relative;
      /* For proper Pyxel canvas positioning */
    }


    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
    }

    .modal-content {
      background-color: #2d2d2d;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #444;
      width: 50%;
      max-width: 500px;
      border-radius: 8px;
      color: #fff;
      font-family: "Press Start 2P", serif;
      font-size: 12px;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-title {
      font-size: 16px;
    }

    .close-modal {
      color: #888;
      font-size: 20px;
      cursor: pointer;
    }

    .close-modal:hover {
      color: #fff;
    }

    .modal-body {
      margin-bottom: 20px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .modal-input {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      background-color: #333;
      border: 1px solid #444;
      color: #fff;
      font-family: monospace;
      border-radius: 4px;
    }

    .modal-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: "Press Start 2P", serif;
      font-size: 10px;
    }

    .modal-btn-primary {
      background-color: #4CAF50;
      color: white;
    }

    .modal-btn-secondary {
      background-color: #555;
      color: white;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="editor-panel">
      <div class="editor-actions">
        <div class="examples-dropdown">
          <button class="action-button" id="examples-button">ðŸŽ® Examples</button>
          <div class="dropdown-content">
            <a href="#" data-example="snake">Snake Game</a>
            <a href="#" data-example="platformer">Platform Jumper</a>
            <a href="#" data-example="shooter">Space Shooter</a>
            <a href="#" data-example="puzzle">Block Puzzle</a>
            <a href="#" data-example="pong">Pong Classic</a>
          </div>
        </div>
        <div class="spacer"></div>
        <button class="action-button" id="save-button">ðŸ’¾ Save Project</button>
        <button class="action-button" id="load-button">ðŸ“‚ Load Project</button>
      </div>
      <div class="editor-tabs">
        <button class="editor-tab active" data-tab="tab1">main.py <span class="editor-tab-close">Ã—</span></button>
        <button class="new-tab-button">+</button>
      </div>
      <div class="editor-container">
        <div id="editor-tab1" class="editor-instance active">import pyxel

pyxel.init(160, 120)

def update():
  if pyxel.btnp(pyxel.KEY_Q):
    pyxel.quit()

def draw():
  pyxel.cls(0)
  pyxel.text(55, 41, "Hello, Pyxel!", pyxel.frame_count % 16)

pyxel.run(update, draw)</div>
      </div>
    </div>

    <div class="resizer" id="panel-resizer"></div>

    <div class="right-panel">
      <input type="radio" id="tab1" name="tabs" class="tab-radio">
      <input type="radio" id="tab2" name="tabs" class="tab-radio" checked>

      <div class="tab-controls">
        <label for="tab1">Media</label>
        <label for="tab2">Game</label>
      </div>

      <div id="content1" class="tab-content">
        <!-- Media Editor Container will be populated dynamically -->
      </div>
      <div id="content2" class="tab-content">
        <!-- Game Container will be populated dynamically -->
      </div>
    </div>
  </div>


  <!-- Save Project Modal -->
  <div id="save-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Save Project</h2>
        <span class="close-modal" id="close-save-modal">Ã—</span>
      </div>
      <div class="modal-body">
        <label for="project-name">Project Name:</label>
        <input type="text" id="project-name" class="modal-input" placeholder="My Pyxel Game">
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-secondary" id="cancel-save">Cancel</button>
        <button class="modal-btn modal-btn-primary" id="confirm-save">Save</button>
      </div>
    </div>
  </div>

  <!-- Load Project Modal -->
  <div id="load-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Load Project</h2>
        <span class="close-modal" id="close-load-modal">Ã—</span>
      </div>
      <div class="modal-body">
        <div id="projects-list">
          <p>No saved projects found.</p>
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-secondary" id="cancel-load">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    // Store all editors in an object
    const editors = {};
    let activeTab = 'tab1';
    const FILE_NAME_ATTR = 'data-filename';

    // Initialize the first editor
    editors.tab1 = ace.edit("editor-tab1");
    editors.tab1.setTheme("ace/theme/monokai");
    editors.tab1.session.setMode("ace/mode/python");
    editors.tab1.setOptions({
        fontSize: "14px",
        showPrintMargin: false,
        highlightActiveLine: true,
        enableLiveAutocompletion: true
    });

    // Set the filename attribute for the first tab
    document.querySelector('.editor-tab[data-tab="tab1"]').setAttribute(FILE_NAME_ATTR, 'main.py');

    // Function to create a new tab with editor
    function createNewTab(filename = 'untitled.py', content = '') {
        // Create a new tab ID
        const tabId = 'tab' + (Object.keys(editors).length + 1);
        
        // Create tab button
        const tabButton = document.createElement('button');
        tabButton.className = 'editor-tab';
        tabButton.setAttribute('data-tab', tabId);
        tabButton.setAttribute(FILE_NAME_ATTR, filename);
        tabButton.innerHTML = filename + ' <span class="editor-tab-close">Ã—</span>';
        
        // Insert before the new tab button
        const newTabButton = document.querySelector('.new-tab-button');
        document.querySelector('.editor-tabs').insertBefore(tabButton, newTabButton);
        
        // Create editor div
        const editorDiv = document.createElement('div');
        editorDiv.id = 'editor-' + tabId;
        editorDiv.className = 'editor-instance';
        editorDiv.textContent = content;
        document.querySelector('.editor-container').appendChild(editorDiv);
        
        // Initialize Ace editor for this tab
        editors[tabId] = ace.edit(editorDiv.id);
        editors[tabId].setTheme("ace/theme/monokai");
        editors[tabId].session.setMode("ace/mode/python");
        editors[tabId].setOptions({
            fontSize: "14px",
            showPrintMargin: false,
            highlightActiveLine: true,
            enableLiveAutocompletion: true
        });
        
        // Set the content
        if (content) {
            editors[tabId].setValue(content, -1);
        }
        
        // Activate the new tab
        activateTab(tabId);
        
        return tabId;
    }

    // Function to activate a tab
    function activateTab(tabId) {
        // Deactivate all tabs
        document.querySelectorAll('.editor-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        document.querySelectorAll('.editor-instance').forEach(editor => {
            editor.classList.remove('active');
        });
        
        // Activate selected tab
        document.querySelector(`.editor-tab[data-tab="${tabId}"]`).classList.add('active');
        document.getElementById(`editor-${tabId}`).classList.add('active');
        
        activeTab = tabId;
    }

    // Function to close a tab
    function closeTab(tabId) {
        // Don't close if it's the last tab
        if (Object.keys(editors).length <= 1) return;
        
        // Remove tab button
        const tabButton = document.querySelector(`.editor-tab[data-tab="${tabId}"]`);
        tabButton.remove();
        
        // Remove editor instance
        const editorDiv = document.getElementById(`editor-${tabId}`);
        editorDiv.remove();
        
        // Destroy Ace editor instance
        editors[tabId].destroy();
        delete editors[tabId];
        
        // Activate another tab
        const newActiveTab = Object.keys(editors)[0];
        activateTab(newActiveTab);
    }

    // Event listener for tab clicks
    document.querySelector('.editor-tabs').addEventListener('click', (e) => {
        // Handle tab activation
        if (e.target.classList.contains('editor-tab')) {
            const tabId = e.target.getAttribute('data-tab');
            activateTab(tabId);
        }
        
        // Handle tab close
        if (e.target.classList.contains('editor-tab-close')) {
            const tabId = e.target.parentElement.getAttribute('data-tab');
            closeTab(tabId);
            e.stopPropagation(); // Prevent tab activation
        }
        
        // Handle new tab creation
        if (e.target.classList.contains('new-tab-button')) {
            createNewTab();
        }
    });


    // Media and game iframe management
    let resourceData = "";
    let gameIframe = null;
    let mediaIframe = null;
    
    // Handle messages from iframes
    window.addEventListener('message', (event) => {
        if (event.data.type === 'pyxelResourceUpdate') {
            // Update the resource data
            resourceData = event.data.data;
            
            // Update game with new resource data if it exists
            if (gameIframe) {
                updateGame();
            }
        }
    });
    
    // Function to create the media editor iframe
    function createMediaEditor() {
        const mediaContainer = document.getElementById('content1');
        
        // Clear the container
        mediaContainer.innerHTML = '';
        
        // Create the iframe
        mediaIframe = document.createElement('iframe');
        mediaIframe.style.width = '100%';
        mediaIframe.style.height = '100%';
        mediaIframe.style.border = 'none';
        mediaIframe.src = 'media.html';
        
        mediaContainer.appendChild(mediaIframe);
    }
    
    // Function to update or create the game iframe
    function updateGame() {
        const gameContainer = document.getElementById('content2');
        const code = editors[activeTab].getValue();
        
        // Store the code in sessionStorage to avoid URL size limitations
        sessionStorage.setItem('pyxelCode', code);
        sessionStorage.setItem('pyxelResource', resourceData);
        
        // If there's an existing iframe, just update its src
        if (gameIframe && gameIframe.parentNode === gameContainer) {
            gameIframe.src = 'player.html?useSessionStorage=true';
        } else {
            // Create a new iframe
            gameContainer.innerHTML = '';
            gameIframe = document.createElement('iframe');
            gameIframe.style.width = '100%';
            gameIframe.style.height = '100%';
            gameIframe.style.border = 'none';
            
            // Use sessionStorage instead of URL parameters
            gameIframe.src = 'player.html?useSessionStorage=true';
            
            gameContainer.appendChild(gameIframe);
        }
    }
    
    // Handle tab switching
    const tab1Radio = document.getElementById('tab1');
    const tab2Radio = document.getElementById('tab2');
    
    tab1Radio.addEventListener('change', () => {
        if (tab1Radio.checked) {
            // Clear game iframe to free resources
            const gameContainer = document.getElementById('content2');
            gameContainer.innerHTML = '';
            gameIframe = null;
            
            // Create media editor
            createMediaEditor();
        }
    });
    
    tab2Radio.addEventListener('change', () => {
        if (tab2Radio.checked) {
            // Clear media iframe to free resources
            const mediaContainer = document.getElementById('content1');
            mediaContainer.innerHTML = '';
            mediaIframe = null;
            
            // Create/update game
            updateGame();
        }
    });

    // Function to serialize the project
    function serializeProject() {
        const files = {};
        
        // For each editor, get the filename and content
        Object.keys(editors).forEach(tabId => {
            const tabElement = document.querySelector(`.editor-tab[data-tab="${tabId}"]`);
            const filename = tabElement.getAttribute(FILE_NAME_ATTR);
            const content = editors[tabId].getValue();
            
            files[filename] = content;
        });
        
        return {
            files: files,
            resourceData: resourceData
        };
    }
    
    // Function to deserialize and load a project
    function deserializeProject(projectData) {
        // Clear existing tabs (except the first one)
        Object.keys(editors).forEach(tabId => {
            if (tabId !== 'tab1') {
                closeTab(tabId);
            }
        });
        
        // Set the content of the first tab
        const firstFile = Object.keys(projectData.files)[0];
        const firstContent = projectData.files[firstFile];
        
        const firstTab = document.querySelector('.editor-tab[data-tab="tab1"]');
        firstTab.setAttribute(FILE_NAME_ATTR, firstFile);
        firstTab.innerHTML = firstFile + ' <span class="editor-tab-close">Ã—</span>';
        
        editors.tab1.setValue(firstContent, -1);
        
        // Create tabs for remaining files
        Object.keys(projectData.files).slice(1).forEach(filename => {
            createNewTab(filename, projectData.files[filename]);
        });
        
        // Set resource data
        resourceData = projectData.resourceData || "";
        
        // Activate the first tab
        activateTab('tab1');
        
        // If game tab is selected, update the game display
        if (tab2Radio.checked) {
            updateGame();
        }
    }
    
    // Save Project Modal Functions
    const saveModal = document.getElementById('save-modal');
    const closeModalBtn = document.getElementById('close-save-modal');
    const saveProjectBtn = document.getElementById('save-button');
    const cancelSaveBtn = document.getElementById('cancel-save');
    const confirmSaveBtn = document.getElementById('confirm-save');
    const projectNameInput = document.getElementById('project-name');
    
    saveProjectBtn.addEventListener('click', () => {
        saveModal.style.display = 'block';
        projectNameInput.focus();
    });
    
    function closeSaveModal() {
        saveModal.style.display = 'none';
    }
    
    closeModalBtn.addEventListener('click', closeSaveModal);
    cancelSaveBtn.addEventListener('click', closeSaveModal);
    
    confirmSaveBtn.addEventListener('click', () => {
        const projectName = projectNameInput.value.trim() || 'Untitled Project';
        
        // Serialize the project
        const projectData = serializeProject();
        
        // Get existing projects or initialize new storage
        const savedProjects = JSON.parse(localStorage.getItem('pyxelProjects') || '{}');
        
        // Save this project
        savedProjects[projectName] = {
            timestamp: new Date().toISOString(),
            data: projectData
        };
        
        // Store back to localStorage
        localStorage.setItem('pyxelProjects', JSON.stringify(savedProjects));
        
        closeSaveModal();
        
        // Show feedback
        alert(`Project "${projectName}" saved successfully!`);
    });
    
    // Load Project Modal Functions
    const loadModal = document.getElementById('load-modal');
    const closeLoadModalBtn = document.getElementById('close-load-modal');
    const loadProjectBtn = document.getElementById('load-button');
    const cancelLoadBtn = document.getElementById('cancel-load');
    const projectsList = document.getElementById('projects-list');
    
    function populateProjectsList() {
        projectsList.innerHTML = '';
        
        const savedProjects = JSON.parse(localStorage.getItem('pyxelProjects') || '{}');
        const projectNames = Object.keys(savedProjects);
        
        if (projectNames.length === 0) {
            projectsList.innerHTML = '<p>No saved projects found.</p>';
            return;
        }
        
        // Sort projects by timestamp (newest first)
        projectNames.sort((a, b) => {
            const timeA = new Date(savedProjects[a].timestamp).getTime();
            const timeB = new Date(savedProjects[b].timestamp).getTime();
            return timeB - timeA;
        });
        
        // Create list of projects
        const projectsListEl = document.createElement('ul');
        projectsListEl.style.listStyle = 'none';
        projectsListEl.style.padding = '0';
        
        projectNames.forEach(name => {
            const project = savedProjects[name];
            const date = new Date(project.timestamp).toLocaleDateString();
            
            const li = document.createElement('li');
            li.style.padding = '8px';
            li.style.margin = '4px 0';
            li.style.background = '#333';
            li.style.borderRadius = '4px';
            li.style.display = 'flex';
            li.style.justifyContent = 'space-between';
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = name;
            
            const dateSpan = document.createElement('span');
            dateSpan.textContent = date;
            dateSpan.style.color = '#888';
            dateSpan.style.fontSize = '8px';
            
            const actionsDiv = document.createElement('div');
            
            const loadBtn = document.createElement('button');
            loadBtn.textContent = 'Load';
            loadBtn.className = 'modal-btn modal-btn-primary';
            loadBtn.style.marginRight = '4px';
            loadBtn.style.padding = '4px 8px';
            loadBtn.style.fontSize = '8px';
            
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete';
            deleteBtn.className = 'modal-btn modal-btn-secondary';
            deleteBtn.style.padding = '4px 8px';
            deleteBtn.style.fontSize = '8px';
            
            // Add event listeners
            loadBtn.addEventListener('click', () => {
                deserializeProject(project.data);
                closeLoadModal();
            });
            
            deleteBtn.addEventListener('click', () => {
                if (confirm(`Are you sure you want to delete "${name}"?`)) {
                    delete savedProjects[name];
                    localStorage.setItem('pyxelProjects', JSON.stringify(savedProjects));
                    populateProjectsList();
                }
            });
            
            actionsDiv.appendChild(loadBtn);
            actionsDiv.appendChild(deleteBtn);
            
            li.appendChild(nameSpan);
            li.appendChild(dateSpan);
            li.appendChild(actionsDiv);
            
            projectsListEl.appendChild(li);
        });
        
        projectsList.appendChild(projectsListEl);
    }
    
    loadProjectBtn.addEventListener('click', () => {
        populateProjectsList();
        loadModal.style.display = 'block';
    });
    
    function closeLoadModal() {
        loadModal.style.display = 'none';
    }
    
    closeLoadModalBtn.addEventListener('click', closeLoadModal);
    cancelLoadBtn.addEventListener('click', closeLoadModal);

    // Add event listener to update the game when code changes
    Object.values(editors).forEach(editor => {
        editor.session.on('change', () => {
            // Only update game if game tab is active
            if (tab2Radio.checked && gameIframe) {
                updateGame();
            }
        });
    });
    
    // Initialize the game on page load 
    // Wait for DOM to be fully loaded
    document.addEventListener('DOMContentLoaded', () => {
        // Make sure Game tab is selected (should already be checked in HTML)
        tab2Radio.checked = true;
        
        // Initialize the game view
        updateGame();
    });
    
    // Initialize the game immediately in case DOMContentLoaded already fired
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        updateGame();
    }
    
    // Example project templates
    const exampleProjects = {
        snake: {
            files: {
                'main.py': `import pyxel

# Snake Game Example
# Use arrow keys to move the snake
# Eat the food to grow

WIDTH, HEIGHT = 160, 120
GRID_SIZE = 8

class Snake:
    def __init__(self):
        self.body = [(10, 10)]
        self.direction = (1, 0)
        self.food = (15, 15)
        self.score = 0
        self.game_over = False
        
    def update(self):
        if self.game_over:
            if pyxel.btnp(pyxel.KEY_R):
                self.__init__()
            return
            
        # Handle Input
        if pyxel.btnp(pyxel.KEY_UP) and self.direction != (0, 1):
            self.direction = (0, -1)
        elif pyxel.btnp(pyxel.KEY_DOWN) and self.direction != (0, -1):
            self.direction = (0, 1)
        elif pyxel.btnp(pyxel.KEY_LEFT) and self.direction != (1, 0):
            self.direction = (-1, 0)
        elif pyxel.btnp(pyxel.KEY_RIGHT) and self.direction != (-1, 0):
            self.direction = (1, 0)
            
        # Move snake
        head_x, head_y = self.body[0]
        new_head = (head_x + self.direction[0], head_y + self.direction[1])
        
        # Check for collisions
        if (new_head[0] < 0 or new_head[0] >= WIDTH // GRID_SIZE or
            new_head[1] < 0 or new_head[1] >= HEIGHT // GRID_SIZE or
            new_head in self.body):
            self.game_over = True
            return
            
        self.body.insert(0, new_head)
        
        # Check for food
        if new_head == self.food:
            self.score += 1
            # Generate new food position
            while True:
                food_x = pyxel.rndi(0, WIDTH // GRID_SIZE - 1)
                food_y = pyxel.rndi(0, HEIGHT // GRID_SIZE - 1)
                self.food = (food_x, food_y)
                if self.food not in self.body:
                    break
        else:
            self.body.pop()  # Remove tail if not eating
    
    def draw(self):
        # Draw background
        pyxel.cls(0)
        
        # Draw snake
        for i, (x, y) in enumerate(self.body):
            color = 11 if i == 0 else 3  # Head is different color
            pyxel.rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE, color)
            
        # Draw food
        pyxel.rect(self.food[0] * GRID_SIZE, self.food[1] * GRID_SIZE, 
                  GRID_SIZE, GRID_SIZE, 8)
                  
        # Display score
        pyxel.text(5, 5, f"SCORE: {self.score}", 7)
        
        if self.game_over:
            pyxel.text(WIDTH // 2 - 30, HEIGHT // 2, "GAME OVER", 8)
            pyxel.text(WIDTH // 2 - 40, HEIGHT // 2 + 10, "PRESS R TO RESTART", 7)

# Initialize game
snake = Snake()
pyxel.init(WIDTH, HEIGHT, title="Pyxel Snake")
pyxel.frame_rate = 10  # Slower for snake game

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
    snake.update()
    
def draw():
    snake.draw()
    
pyxel.run(update, draw)`
            },
            resourceData: ""
        },
        platformer: {
            files: {
                'main.py': `import pyxel

# Simple Platform Game
# Use arrow keys to move and space to jump

WIDTH, HEIGHT = 160, 120
GRAVITY = 0.5
JUMP_POWER = 7
MOVE_SPEED = 2

class Player:
    def __init__(self):
        self.x = 40
        self.y = 100
        self.width = 8
        self.height = 8
        self.vy = 0
        self.vx = 0
        self.on_ground = False
    
    def update(self):
        # Movement
        self.vx = 0
        if pyxel.btn(pyxel.KEY_LEFT):
            self.vx = -MOVE_SPEED
        if pyxel.btn(pyxel.KEY_RIGHT):
            self.vx = MOVE_SPEED
            
        # Apply horizontal movement
        self.x += self.vx
        
        # Handle boundaries
        if self.x < 0:
            self.x = 0
        if self.x > WIDTH - self.width:
            self.x = WIDTH - self.width
            
        # Apply gravity
        self.vy += GRAVITY
        self.y += self.vy
        
        # Simple platform collision (fixed platform)
        platforms = [
            (10, 80, 40, 8),   # (x, y, width, height)
            (60, 60, 40, 8),
            (100, 90, 50, 8),
            (0, 110, WIDTH, 10) # Ground
        ]
        
        self.on_ground = False
        for p_x, p_y, p_w, p_h in platforms:
            # Check if player is colliding with platform
            if (self.x < p_x + p_w and self.x + self.width > p_x and
                self.y < p_y + p_h and self.y + self.height > p_y):
                
                # Coming from above (landing on platform)
                if self.vy > 0 and self.y < p_y:
                    self.y = p_y - self.height
                    self.vy = 0
                    self.on_ground = True
                
                # Hit ceiling
                elif self.vy < 0 and self.y + self.height > p_y + p_h:
                    self.y = p_y + p_h
                    self.vy = 0
                
                # Hit left side
                elif self.vx > 0 and self.x < p_x:
                    self.x = p_x - self.width
                
                # Hit right side
                elif self.vx < 0 and self.x + self.width > p_x + p_w:
                    self.x = p_x + p_w
        
        # Jump when space is pressed and on ground
        if pyxel.btnp(pyxel.KEY_SPACE) and self.on_ground:
            self.vy = -JUMP_POWER
            self.on_ground = False
            
    def draw(self):
        # Draw player
        pyxel.rect(self.x, self.y, self.width, self.height, 11)
        
        # Draw platforms
        platforms = [
            (10, 80, 40, 8),
            (60, 60, 40, 8),
            (100, 90, 50, 8),
            (0, 110, WIDTH, 10)
        ]
        
        for p_x, p_y, p_w, p_h in platforms:
            pyxel.rect(p_x, p_y, p_w, p_h, 3)

# Initialize game
player = Player()
pyxel.init(WIDTH, HEIGHT, title="Pyxel Platformer")

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
    player.update()
    
def draw():
    pyxel.cls(0)
    player.draw()
    pyxel.text(5, 5, "ARROWS: MOVE, SPACE: JUMP", 7)
    
pyxel.run(update, draw)`
            },
            resourceData: ""
        },
        shooter: {
            files: {
                'main.py': `import pyxel

# Space Shooter Example
# Use arrow keys to move and space to shoot

WIDTH, HEIGHT = 160, 120

class Player:
    def __init__(self):
        self.x = WIDTH // 2
        self.y = HEIGHT - 20
        self.width = 8
        self.height = 8
        self.speed = 2
        self.bullets = []
        self.shoot_cooldown = 0
        
    def update(self):
        # Movement
        if pyxel.btn(pyxel.KEY_LEFT):
            self.x = max(0, self.x - self.speed)
        if pyxel.btn(pyxel.KEY_RIGHT):
            self.x = min(WIDTH - self.width, self.x + self.speed)
            
        # Shooting
        if self.shoot_cooldown > 0:
            self.shoot_cooldown -= 1
            
        if pyxel.btn(pyxel.KEY_SPACE) and self.shoot_cooldown == 0:
            self.bullets.append([self.x + self.width // 2, self.y])
            self.shoot_cooldown = 10
            
        # Update bullets
        for bullet in self.bullets[:]:
            bullet[1] -= 4  # Move bullet up
            if bullet[1] < 0:
                self.bullets.remove(bullet)
    
    def draw(self):
        # Draw player
        pyxel.rect(self.x, self.y, self.width, self.height, 11)
        
        # Draw bullets
        for x, y in self.bullets:
            pyxel.rect(x - 1, y, 2, 4, 10)

class Enemy:
    def __init__(self):
        self.enemies = []
        self.spawn_timer = 0
        
    def update(self):
        # Spawn new enemies
        if self.spawn_timer == 0:
            x = pyxel.rndi(0, WIDTH - 8)
            self.enemies.append([x, 0])
            self.spawn_timer = 30
        else:
            self.spawn_timer -= 1
            
        # Move enemies down
        for enemy in self.enemies[:]:
            enemy[1] += 1
            
            # Remove if off screen
            if enemy[1] > HEIGHT:
                self.enemies.remove(enemy)
                
    def check_collision(self, player):
        # Check bullet collisions
        for bullet in player.bullets[:]:
            for enemy in self.enemies[:]:
                if (bullet[0] > enemy[0] and bullet[0] < enemy[0] + 8 and
                    bullet[1] > enemy[1] and bullet[1] < enemy[1] + 8):
                    if bullet in player.bullets:
                        player.bullets.remove(bullet)
                    if enemy in self.enemies:
                        self.enemies.remove(enemy)
    
    def draw(self):
        # Draw enemies
        for x, y in self.enemies:
            pyxel.rect(x, y, 8, 8, 8)

# Initialize game
player = Player()
enemies = Enemy()
score = 0

pyxel.init(WIDTH, HEIGHT, title="Pyxel Shooter")

def update():
    global score
    
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
        
    player.update()
    enemies.update()
    
    # Check collisions and update score
    old_enemy_count = len(enemies.enemies)
    enemies.check_collision(player)
    score += old_enemy_count - len(enemies.enemies)
    
def draw():
    pyxel.cls(0)
    
    player.draw()
    enemies.draw()
    
    # Display score
    pyxel.text(5, 5, f"SCORE: {score}", 7)
    
pyxel.run(update, draw)`
            },
            resourceData: ""
        },
        puzzle: {
            files: {
                'main.py': `import pyxel

# Block Puzzle Game
# Use arrow keys to move blocks
# Complete rows to clear them

WIDTH, HEIGHT = 160, 120
GRID_SIZE = 12
GRID_WIDTH = WIDTH // GRID_SIZE
GRID_HEIGHT = HEIGHT // GRID_SIZE

class PuzzleGame:
    def __init__(self):
        # Create empty grid
        self.grid = [[0 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
        
        # Create a block at the top
        self.current_block = {
            'x': GRID_WIDTH // 2,
            'y': 0,
            'shape': [[1, 1], [1, 1]] # 2x2 square
        }
        
        self.game_over = False
        self.score = 0
        self.move_timer = 0
        self.move_speed = 15  # Frames between moves
        
    def can_move(self, dx, dy):
        # Check if the current block can move in the specified direction
        for y, row in enumerate(self.current_block['shape']):
            for x, cell in enumerate(row):
                if cell == 0:
                    continue
                    
                new_x = self.current_block['x'] + x + dx
                new_y = self.current_block['y'] + y + dy
                
                # Check boundaries
                if (new_x < 0 or new_x >= GRID_WIDTH or 
                    new_y >= GRID_HEIGHT):
                    return False
                    
                # Check collision with placed blocks
                if new_y >= 0 and self.grid[new_y][new_x] != 0:
                    return False
                    
        return True
    
    def place_block(self):
        # Fix the current block in place
        for y, row in enumerate(self.current_block['shape']):
            for x, cell in enumerate(row):
                if cell == 0:
                    continue
                    
                grid_y = self.current_block['y'] + y
                grid_x = self.current_block['x'] + x
                
                if grid_y >= 0:  # Only place visible blocks
                    self.grid[grid_y][grid_x] = cell
                    
        # Check for completed rows
        completed_rows = []
        for y in range(GRID_HEIGHT):
            if all(self.grid[y]):
                completed_rows.append(y)
        
        # Clear completed rows
        for row in completed_rows:
            del self.grid[row]
            self.grid.insert(0, [0 for _ in range(GRID_WIDTH)])
            self.score += 10
            
        # Create new block
        shapes = [
            [[1, 1], [1, 1]],  # Square
            [[0, 1, 0], [1, 1, 1]],  # T
            [[1, 1, 0], [0, 1, 1]],  # Z
            [[0, 1, 1], [1, 1, 0]],  # S
            [[1, 0, 0], [1, 1, 1]]   # L
        ]
        
        self.current_block = {
            'x': GRID_WIDTH // 2 - 1,
            'y': 0,
            'shape': shapes[pyxel.rndi(0, len(shapes) - 1)]
        }
        
        # Check for game over (collision in starting position)
        for y, row in enumerate(self.current_block['shape']):
            for x, cell in enumerate(row):
                if cell == 0:
                    continue
                
                grid_y = self.current_block['y'] + y
                grid_x = self.current_block['x'] + x
                
                if grid_y >= 0 and self.grid[grid_y][grid_x] != 0:
                    self.game_over = True
    
    def update(self):
        if self.game_over:
            if pyxel.btnp(pyxel.KEY_R):
                self.__init__()
            return
            
        # Handle input
        if pyxel.btnp(pyxel.KEY_LEFT) and self.can_move(-1, 0):
            self.current_block['x'] -= 1
            
        if pyxel.btnp(pyxel.KEY_RIGHT) and self.can_move(1, 0):
            self.current_block['x'] += 1
            
        if pyxel.btnp(pyxel.KEY_DOWN):
            # Move down faster
            self.move_timer = self.move_speed
            
        if pyxel.btnp(pyxel.KEY_UP):
            # Rotate (simplified - only works for some shapes)
            old_shape = self.current_block['shape']
            height = len(old_shape)
            width = len(old_shape[0])
            
            # Create rotated shape
            new_shape = [[0 for _ in range(height)] for _ in range(width)]
            
            for y in range(height):
                for x in range(width):
                    new_shape[x][height - 1 - y] = old_shape[y][x]
                    
            # Store old shape in case we need to revert
            self.current_block['shape'] = new_shape
            
            # Revert if rotation causes collision
            if not self.can_move(0, 0):
                self.current_block['shape'] = old_shape
            
        # Auto-drop movement
        self.move_timer += 1
        if self.move_timer >= self.move_speed:
            self.move_timer = 0
            
            if self.can_move(0, 1):
                self.current_block['y'] += 1
            else:
                self.place_block()
    
    def draw(self):
        pyxel.cls(0)
        
        # Draw grid
        for y in range(GRID_HEIGHT):
            for x in range(GRID_WIDTH):
                if self.grid[y][x] != 0:
                    pyxel.rect(x * GRID_SIZE, y * GRID_SIZE, 
                              GRID_SIZE - 1, GRID_SIZE - 1, 11)
        
        # Draw current block
        for y, row in enumerate(self.current_block['shape']):
            for x, cell in enumerate(row):
                if cell == 0:
                    continue
                    
                draw_x = (self.current_block['x'] + x) * GRID_SIZE
                draw_y = (self.current_block['y'] + y) * GRID_SIZE
                
                if draw_y >= 0:  # Only draw visible parts
                    pyxel.rect(draw_x, draw_y, GRID_SIZE - 1, GRID_SIZE - 1, 8)
        
        # Draw score
        pyxel.text(5, 5, f"SCORE: {self.score}", 7)
        
        if self.game_over:
            pyxel.text(WIDTH // 2 - 30, HEIGHT // 2, "GAME OVER", 8)
            pyxel.text(WIDTH // 2 - 40, HEIGHT // 2 + 10, "PRESS R TO RESTART", 7)

# Initialize game
puzzle = PuzzleGame()
pyxel.init(WIDTH, HEIGHT, title="Pyxel Block Puzzle")

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
    puzzle.update()
    
def draw():
    puzzle.draw()
    
pyxel.run(update, draw)`
            },
            resourceData: ""
        },
        pong: {
            files: {
                'main.py': `import pyxel

# Pong Classic Example
# Player 1: W/S keys
# Player 2: Up/Down arrows

WIDTH, HEIGHT = 160, 120
PADDLE_WIDTH = 4
PADDLE_HEIGHT = 20
BALL_SIZE = 4
PADDLE_SPEED = 2
BALL_SPEED = 1.5

class Pong:
    def __init__(self):
        # Paddles [x, y]
        self.paddle1 = [5, HEIGHT // 2 - PADDLE_HEIGHT // 2]
        self.paddle2 = [WIDTH - 5 - PADDLE_WIDTH, HEIGHT // 2 - PADDLE_HEIGHT // 2]
        
        # Ball [x, y, dx, dy]
        self.ball = [WIDTH // 2, HEIGHT // 2, -BALL_SPEED, BALL_SPEED * 0.5]
        
        # Scores
        self.score1 = 0
        self.score2 = 0
        
    def update(self):
        # Player 1 controls
        if pyxel.btn(pyxel.KEY_W):
            self.paddle1[1] = max(0, self.paddle1[1] - PADDLE_SPEED)
        if pyxel.btn(pyxel.KEY_S):
            self.paddle1[1] = min(HEIGHT - PADDLE_HEIGHT, self.paddle1[1] + PADDLE_SPEED)
            
        # Player 2 controls
        if pyxel.btn(pyxel.KEY_UP):
            self.paddle2[1] = max(0, self.paddle2[1] - PADDLE_SPEED)
        if pyxel.btn(pyxel.KEY_DOWN):
            self.paddle2[1] = min(HEIGHT - PADDLE_HEIGHT, self.paddle2[1] + PADDLE_SPEED)
            
        # Move ball
        self.ball[0] += self.ball[2]
        self.ball[1] += self.ball[3]
        
        # Ball collision with top/bottom
        if self.ball[1] <= 0 or self.ball[1] >= HEIGHT - BALL_SIZE:
            self.ball[3] = -self.ball[3]
            
        # Ball collision with paddles
        # Paddle 1
        if (self.ball[0] <= self.paddle1[0] + PADDLE_WIDTH and 
            self.ball[1] + BALL_SIZE >= self.paddle1[1] and 
            self.ball[1] <= self.paddle1[1] + PADDLE_HEIGHT):
            self.ball[0] = self.paddle1[0] + PADDLE_WIDTH
            self.ball[2] = -self.ball[2]
            # Add some randomness to bounce
            self.ball[3] += pyxel.rndf(-0.5, 0.5)
            
        # Paddle 2
        if (self.ball[0] + BALL_SIZE >= self.paddle2[0] and 
            self.ball[1] + BALL_SIZE >= self.paddle2[1] and 
            self.ball[1] <= self.paddle2[1] + PADDLE_HEIGHT):
            self.ball[0] = self.paddle2[0] - BALL_SIZE
            self.ball[2] = -self.ball[2]
            # Add some randomness to bounce
            self.ball[3] += pyxel.rndf(-0.5, 0.5)
            
        # Scoring
        if self.ball[0] < 0:
            self.score2 += 1
            self.reset_ball()
        elif self.ball[0] > WIDTH:
            self.score1 += 1
            self.reset_ball()
            
    def reset_ball(self):
        # Reset ball to center with random direction
        self.ball = [
            WIDTH // 2, 
            HEIGHT // 2, 
            BALL_SPEED if pyxel.rndf(0, 1) > 0.5 else -BALL_SPEED,
            pyxel.rndf(-BALL_SPEED, BALL_SPEED)
        ]
    
    def draw(self):
        pyxel.cls(0)
        
        # Draw center line
        for y in range(0, HEIGHT, 8):
            pyxel.rect(WIDTH // 2 - 1, y, 2, 4, 7)
        
        # Draw paddles
        pyxel.rect(self.paddle1[0], self.paddle1[1], PADDLE_WIDTH, PADDLE_HEIGHT, 11)
        pyxel.rect(self.paddle2[0], self.paddle2[1], PADDLE_WIDTH, PADDLE_HEIGHT, 11)
        
        # Draw ball
        pyxel.rect(self.ball[0], self.ball[1], BALL_SIZE, BALL_SIZE, 10)
        
        # Draw scores
        pyxel.text(WIDTH // 4, 10, str(self.score1), 7)
        pyxel.text(3 * WIDTH // 4, 10, str(self.score2), 7)

# Initialize game
pong = Pong()
pyxel.init(WIDTH, HEIGHT, title="Pyxel Pong")

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
    pong.update()
    
def draw():
    pong.draw()
    
pyxel.run(update, draw)`
            },
            resourceData: ""
        }
    };
    
    // Function to load an example project
    function loadExampleProject(exampleId) {
        const example = exampleProjects[exampleId];
        if (!example) return;
        
        // Load the example as a project
        deserializeProject(example);
        
        // Switch to the Game tab to see the result
        tab2Radio.checked = true;
        updateGame();
    }
    
    // Add event listeners for example selection
    document.querySelectorAll('.dropdown-content a').forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const exampleId = e.target.getAttribute('data-example');
            loadExampleProject(exampleId);
        });
    });
    
    // Panel resizer functionality
    const panelResizer = document.getElementById('panel-resizer');
    const editorPanel = document.querySelector('.editor-panel');
    const rightPanel = document.querySelector('.right-panel');
    
    // Initialize with stored panel sizes if available, otherwise use default 50/50
    const storedEditorWidth = localStorage.getItem('pyxelEditorWidth');
    if (storedEditorWidth) {
        editorPanel.style.flex = '0 0 ' + storedEditorWidth + 'px';
    } else {
        // Default to 50% of container width
        const containerWidth = document.querySelector('.container').clientWidth;
        editorPanel.style.flex = '0 0 ' + (containerWidth / 2) + 'px';
    }
    
    // Resize functionality
    let isResizing = false;
    let lastDownX = 0;
    
    panelResizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        lastDownX = e.clientX;
        panelResizer.classList.add('active');
        
        // Prevent text selection during resize
        document.body.style.userSelect = 'none';
        document.body.style.cursor = 'col-resize';
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        
        const containerRect = document.querySelector('.container').getBoundingClientRect();
        const offsetX = e.clientX - containerRect.left;
        
        // Calculate min/max values
        const minWidth = 200; // Minimum editor width
        const maxWidth = containerRect.width - 200; // Maximum editor width (leaving min space for right panel)
        
        // Apply constraints
        const newWidth = Math.min(Math.max(offsetX, minWidth), maxWidth);
        
        // Update editor panel width
        editorPanel.style.flex = '0 0 ' + newWidth + 'px';
        
        // Force Ace editor to update its size
        Object.values(editors).forEach(editor => {
            editor.resize();
        });
    });
    
    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            panelResizer.classList.remove('active');
            
            // Reset cursor and selection
            document.body.style.userSelect = '';
            document.body.style.cursor = '';
            
            // Save the editor width for next time
            const editorWidth = editorPanel.offsetWidth;
            localStorage.setItem('pyxelEditorWidth', editorWidth);
            
            // Make sure editors resize properly
            Object.values(editors).forEach(editor => {
                editor.resize();
            });
        }
    });
    
    // Resize editors when window changes
    window.addEventListener('resize', () => {
        // Resize all editors to fit the new layout
        Object.values(editors).forEach(editor => {
            editor.resize();
        });
        
        // Update game and media iframes if they exist
        if (gameIframe || mediaIframe) {
            // Ensure panels maintain reasonable sizes in new window dimensions
            const containerWidth = document.querySelector('.container').clientWidth;
            const minWidth = 200;
            const currentEditorWidth = parseInt(editorPanel.style.flex.split(' ')[2]);
            
            // If editor is too large or small after resize, adjust it
            if (currentEditorWidth > containerWidth - minWidth || currentEditorWidth < minWidth) {
                const newWidth = Math.min(Math.max(containerWidth / 2, minWidth), containerWidth - minWidth);
                editorPanel.style.flex = '0 0 ' + newWidth + 'px';
            }
        }
    });

    document.addEventListener('click', (event) => {
        // Get the Pyxel canvas element (created by Pyxel)
        const pyxelCanvas = document.querySelector('#canvas');
        if (!pyxelCanvas) return;  // Exit if game isn't running

        // Check if click was outside the Pyxel canvas
        if (!pyxelCanvas.contains(event.target)) {
            // Create and dispatch an Escape key event
            const escEvent = new KeyboardEvent('keydown', {
                key: 'Escape',
                code: 'Escape',
                keyCode: 27,
                which: 27,
                bubbles: true,
                cancelable: true
            });
            
            pyxelCanvas.dispatchEvent(escEvent);
        }
    });
  </script>
</body>

</html>